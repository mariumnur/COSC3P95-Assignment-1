# COSC3P95-Assignment-1

Question 1:
Explain the difference between "sound" and "complete" analysis in software analysis. Then, define what true positive, true negative, false positive, and false negative mean. How would these terms change if the goal of the analysis changes, particularly when "positive" means finding a bug, and then when "positive" means not finding a bug. (10 pts)

Sound refers to the ability of an analysis technique or tool to not report any false positives. It never reports a bug or vulnerability that does not actually exist. 
Complete refers to the ability of an analysis technique or tool to detect all actual bugs and vulnerabilities that exist in the software. If a bug exists, it will be reported. Complete Analysis prevents false negatives.

False positive refers to when a tool reports a vulnerability when none exists. 
False negative refers to when a tool does not report a vulnerability that exist. 
True positive refers to when a tool reports a vulnerability that actually exists. 
True negative refers to when a tool does not report a vulnerability that does not exist. 

If positive means finding a bug, then the terms would have the same meanings as stated above. 

On the other hand, if positive means not finding a bug then the meanings would be as stated below:
True positive refers to when a tool does not report a vulnerability that does not exist.
True negative refers to when a tool reports a vulnerability that actually exists. 
False negative refers to when a tool reports a vulnerability when none exists.
False positive refers to when a tool does not report a vulnerability that exist.

Question 2:
Using your preferred programming language, implement a random test case generator for a sorting algorithm program that sorts integers in ascending order. The test case generator should be designed to produce arrays of integers with random lengths, and values for each sorting method. 
  A) Your submission should consist of:
        a.	Source code files for the sorting algorithm and the random test case generator.
        b.	Explanation of how your method/approach works and a discussion of the results (for example, if and how the method was able to generate or find any bugs, etc.). You can also include bugs in your code and show your method is able to find the input values causing that.
        c.	Comments within the code for better understanding of the code.
        d.	Instructions for compiling and running your code.
        e.	Logs generated by the print statements, capturing both input array, output arrays for each run of the program.
        f.	Logs for the random test executions, showing if the test was a pass and the output of the execution (e.g., exception, bug message, etc.).

  B) Provide a context-free grammar to generate all the possible test-cases. (18 + 8 = 26 pts)

Solution:

	A)
A basic sort() algorithm has been implemented to arrange an array in ascending order. The printArray function prints every element of the array in an orderly manner. array_generator returns a randomly generated array which has a random length and integer variables are randomly assigned. In this case, I have use built in java functions so that the array length is between 0 and 29. Additionally, the integer values would be between 0 and 1000. 
random_test() conducts 10 random tests on the sort() function. For each iteration, a random array is generated which is run through the sort() function to rearrange the elements. The function then checks if the array elements are larger than the element before. It then says if the expected out has been produced. 

If we were to add a mutation to the code where ‘if (a[j]>a[j+1])’ is changed to ‘if (a[j]<a[j+1])’. The test cases would fail since the excepted output would not be produced. 

Screenshot of the output log (without any mutation):
![image](https://github.com/mariumnur/COSC3P95-Assignment-1/assets/146689055/6b68b238-d0be-4fad-bf46-d2ba187e9033)

Screenshot of the output log (with mutation):
![image](https://github.com/mariumnur/COSC3P95-Assignment-1/assets/146689055/9f26784d-7166-4d4d-ac07-807678d6f3af)

  B) a context-free grammar to generate all the possible test-cases: 

test_case → array*
array → [ ] | [x] | [x,x] | [x,x,x] | …. | [x,x,…,x]
x → x_lower_bound | … -1 | 0 | 1 … | x_upper_bound  

Question 3:
A) For the following code, manually draw a control flow graph to represent its logic and structure.

def filterData(data, limit, exceptions):
    filtered_data = []
    index = 0
    while index < len(data):
        item = data[index]
        if item in exceptions:
            modified_item = item + "_EXCEPTION
        elif item > limit:
            modified_item = item * 2
        else:
            modified_item = item / limit  

        filtered_data.append(modified_item)
        index += 1

    return filtered_data


The code is supposed to perform the followings:
a.	If an item is in the exceptions list, the function appends "_EXCEPTION" to the item.
b.	If an item is greater than a given limit, the function doubles the item.
c.	Otherwise, the function divides the item by 2.

![image](https://github.com/mariumnur/COSC3P95-Assignment-1/assets/146689055/5e40c356-64cd-422d-a342-80f5a650077f)


B) Explain and provide detailed steps for “random testing” the above code. No need to run any code, just present the coding strategy or describe your testing method in detail. (8 + 8 = 16 pts) 

Random testing is a method of testing where test cases are selected from a larger pool of test cases which are then run on the program to help find bugs and defects, making sure specifications are met for the test cash or the execution does not crash. 

For a random testing implementation, test cases would be specified with the input and expected output. A program would be run which would call the filterData function with the test cases as inputs. The output from the function would be matched with the expected out to check for errors/bugs. 

In this case, the American Fuzzy Lop (AFL) could be used. The fuzzer would use the following steps: 
1.	Load the user supplied test cases (set of input parameters for filterData) into a queue.
2.	It would take an input case and attempt to trim the test case to the smallest size making sure it does not affect the program. 
3.	The test input would be repeated mutated (changes in values or the ordering of the data array) using fuzzing strategies 
4.	If the mutated test case results in a state transition recorded by the instrumentation, the mutated entry is added into the queue. 
5.	We then go back to the second step and continue the process. 

The mutated test input cases could be changed to make it helps with high code coverage by taking test cases that go into every if-else case. Additionally, random testing would make sure to check input validation (test cases in an incorrect format), boundary value errors (making sure the while loop in the filterData program does not try to access an array index that might be out of bound), error handling, performance and security issues. 

Question 4:
A) Develop 4 distinct test cases to test the above code, with code coverage ranging from 30% to 100%. For each test-case calculate and mention its code coverage. 

Test case 1: 
	filterData( [1,2,3],1,[1,2,3] )
In this test case, the statement coverage is about 70% while branch coverage is about 30%. Here, all the items in the data array are in exceptions. Therefore, only the first if condition is always accessed. All the other else statements are not checked in any of the while loops, which reduces branch coverage. 

	Test case 2: 
		filterData( [2,3], 1, [2] )
In this test case, the statement coverage is about 85% and branch coverage is about 65%. During the first while loop, the first if case is executed and in the next index, the second case (item>limit) is executed. The third case in the if-else conditions is not executed at all. 

	Test case 3: 
		fiterData( [1,2,0.5], 1, [1] )
In this test case, both the statement and branch coverage would be 100%. The while loop would be executed three times. In each loop, a different if-else condition is executed. 	

	Test case 4:
		filterData([ ], 3, [4])
In this test case, the statement code coverage would be about 30%. Since the data array is empty, the while condition is never met. Therefore, the code never enters the while loop leading to a lower code coverage.  


B) Generate 6 modified (mutated) versions of the above code. 

Mutants: 
1.	index<len(data) →index>len(data)
2.	index<len(data) →index==len(data)
3.	index<len(data) →index!=len(data)
4.	index<len(data) →index<=len(data)
5.	index<len(data) →index>=len(data)
6.	index+=1→index+=2

C) Assess the effectiveness of the test cases from part A by using mutation analysis in conjunction with the mutated codes from part B. Rank the test-cases and explain your answer.

![image](https://github.com/mariumnur/COSC3P95-Assignment-1/assets/146689055/94272f43-bb6a-4463-bf52-a16a0b8feb65)


Test case 4, filterData([ ], 3, [4]) is the worst test case since it produces the same output as the original code for all mutated codes. All the other test cases are the same rank. However, they are not adequate as the third mutant (index<len(data) →index!=len(data)) gives the same results as the original code for all test cases. 


D) Discuss how you would use path, branch, and statement static analysis to evaluate/analyse the above code. (4 * 8 = 32 pts)

Statement static analysis refers to testing single statements. I would use test cases that would allow the statement coverage throughout the entire program. In this case, the test case fiterData( [1,2,0.5], 1, [1] ) gives a statement coverage of 100%. 

Branch static analysis makes sure that each possible outcome from a branch is tested at least once. fiterData( [1,2,0.5], 1, [1] ) results in a branch coverage of 100%. During the while loops, every if-else branch is executed once. 

Path testing refers to making sure that all paths in the program are executed. Therefore, we were to run fiterData( [1,2,0.5], 1, [1] ) or manually execute it using the control flow diagram, we would notice that every path in the control floe diagram is exhausted at the end of the execution of three while loops resulting an outcome for the input. 

Question 5:
The code snippet below aims to switch uppercase characters to their lowercase counterparts and vice versa. Numeric characters are supposed to remain unchanged. The function contains at least one known bug that results in incorrect output for specific inputs.


def processString(input_str):
    output_str = ""
    for char in input_str:
        if char.isupper():
            output_str += char.lower()
        elif char.isnumeric():
            output_str += char * 2  
        else:
            output_str += char.upper()

    return output_str

In this assignment, your tasks are:
a.	Identify the bug(s) in the code. You can either manually review the code (a form of static analysis) or run it with diverse input values (a form of manual random testing). If you are unable to pinpoint the bug using these methods, you may utilize a random testing tool or implement random test case generator in code. Provide a detailed explanation of the bug, identify the line of code causing it, and describe your strategy for finding it.

The bug in the code is in line output_str += char * , a numeric character is supposed to remain unchanged. 
 ![image](https://github.com/mariumnur/COSC3P95-Assignment-1/assets/146689055/a8d2660f-eab6-4da2-866c-5a4d8e6dd534)

I used IDLE Shell to run the function with diverse input values. Every time I used only alphabets, the function gave the expected output. However, with numeric values, the function doubled the numeric value (the string numeric value is repeated twice). However, it is supposed to remain unchanged. 

Changing the line to output_str += char, allows the numeric value to remain unchanged. “*2” would cause the value to be repeated. 

 ![image](https://github.com/mariumnur/COSC3P95-Assignment-1/assets/146689055/b11f43d9-39ac-4d98-8f39-66d215f3015a)


b.	Implement Delta Debugging, in your preferred programming language to minimize the input string that reveals the bug. Test your Delta Debugging code for the following input values provided. 
i.	“abcdefG1”
ii.	“CCDDEExy”
iii.	“1234567b”
iv.	“8665”
 	Briefly explain your delta-debugging algorithm and its implementation and provide the source code in/with your assignment. (4 + 12 = 16 pts)

Delta debugging is an algorithm used for automated debugging, where the main goal is to minimize a test case that produces a bug. 

We can implement delta debugging using the description below:
First start with a binary search where the input string is halved. If one them fails, we continue a binary search on the failed half until we reach a minimised test bug. 
However, if we reach a point where both halves pass, then we increase the input granularity (n*2), and test every subset/change to see if there is failed case. If we find one, we try to continue finding subsets until no longer possible. If we find no failed case, we return the last failed case. 

6	Extra Credit Assignment: Create a GitHub repository to host all the elements of this assignment. This includes source codes, test data, and any screenshots or logs you have generated. Submit the GitHub link along with your main submission through Brightspace. (5 pts)
